<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            background: #262421;
            color: #fff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            margin-top: 30px;
            font-size: 2.5rem;
            letter-spacing: 2px;
        }
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 0;
            border: 4px solid #b58863;
            margin: 40px 0;
            box-shadow: 0 4px 24px #0008;
        }
        .square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            user-select: none;
        }
        .light {
            background: #f0d9b5;
        }
        .dark {
            background: #b58863;
        }
        .selected {
            outline: 3px solid #00aaff;
        }
        .move {
            background: #aee9f5 !important;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            background: #00aaff;
            color: #fff;
            border: none;
            padding: 10px 18px;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #0077aa;
        }
    </style>
    <script>
        // Unicode chess pieces
        const PIECES = {
            'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
            'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
        };

        // Initial board position (FEN)
        let board = [
            ['r','n','b','q','k','b','n','r'],
            ['p','p','p','p','p','p','p','p'],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['P','P','P','P','P','P','P','P'],
            ['R','N','B','Q','K','B','N','R']
        ];

        let selected = null;
        let possibleMoves = [];
        let turn = 'w'; // 'w' for white, 'b' for black

        function renderBoard() {
            const boardDiv = document.getElementById('board');
            boardDiv.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement('div');
                    sq.className = 'square ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
                    sq.dataset.row = r;
                    sq.dataset.col = c;
                    if (selected && selected[0] === r && selected[1] === c) {
                        sq.classList.add('selected');
                    }
                    if (possibleMoves.some(([mr, mc]) => mr === r && mc === c)) {
                        sq.classList.add('move');
                    }
                    const piece = board[r][c];
                    if (piece) sq.textContent = PIECES[piece];
                    sq.onclick = () => handleSquareClick(r, c);
                    boardDiv.appendChild(sq);
                }
            }
            // Update turn display
            document.getElementById('turn-indicator').textContent = "Turn: " + (turn === 'w' ? "White" : "Black");
        }

        function handleSquareClick(r, c) {
            const piece = board[r][c];
            if (selected) {
                // If clicked on a possible move, move the piece
                if (possibleMoves.some(([mr, mc]) => mr === r && mc === c)) {
                    board[r][c] = board[selected[0]][selected[1]];
                    board[selected[0]][selected[1]] = '';
                    turn = turn === 'w' ? 'b' : 'w';
                    selected = null;
                    possibleMoves = [];
                    renderBoard();
                    return;
                }
                // Deselect if clicking the same square
                if (selected[0] === r && selected[1] === c) {
                    selected = null;
                    possibleMoves = [];
                    renderBoard();
                    return;
                }
            }
            // Select piece if it's the player's turn
            if (piece && ((turn === 'w' && piece === piece.toUpperCase()) || (turn === 'b' && piece === piece.toLowerCase()))) {
                selected = [r, c];
                possibleMoves = getMoves(r, c, piece);
                renderBoard();
            }
        }

        // Basic move generation (no castling, en passant, or promotion)
        function getMoves(r, c, piece) {
            let moves = [];
            const isWhite = piece === piece.toUpperCase();
            const directions = {
                'p': isWhite ? [[-1,0]] : [[1,0]],
                'n': [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
                'b': [[-1,-1],[-1,1],[1,-1],[1,1]],
                'r': [[-1,0],[1,0],[0,-1],[0,1]],
                'q': [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]],
                'k': [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]]
            };
            const lower = piece.toLowerCase();

            if (lower === 'p') {
                let dir = isWhite ? -1 : 1;
                // Forward move
                if (inBounds(r+dir, c) && !board[r+dir][c]) {
                    moves.push([r+dir, c]);
                    // Double move from start
                    if ((isWhite && r === 6) || (!isWhite && r === 1)) {
                        if (!board[r+2*dir][c]) moves.push([r+2*dir, c]);
                    }
                }
                // Captures
                for (let dc of [-1,1]) {
                    if (inBounds(r+dir, c+dc) && board[r+dir][c+dc] && isOpponent(board[r+dir][c+dc], isWhite)) {
                        moves.push([r+dir, c+dc]);
                    }
                }
            } else if (lower === 'n') {
                for (let [dr, dc] of directions['n']) {
                    let nr = r+dr, nc = c+dc;
                    if (inBounds(nr, nc) && (!board[nr][nc] || isOpponent(board[nr][nc], isWhite))) {
                        moves.push([nr, nc]);
                    }
                }
            } else if (['b','r','q'].includes(lower)) {
                let dirs = directions[lower];
                for (let [dr, dc] of dirs) {
                    let nr = r+dr, nc = c+dc;
                    while (inBounds(nr, nc)) {
                        if (!board[nr][nc]) {
                            moves.push([nr, nc]);
                        } else {
                            if (isOpponent(board[nr][nc], isWhite)) moves.push([nr, nc]);
                            break;
                        }
                        nr += dr; nc += dc;
                    }
                }
            } else if (lower === 'k') {
                for (let [dr, dc] of directions['k']) {
                    let nr = r+dr, nc = c+dc;
                    if (inBounds(nr, nc) && (!board[nr][nc] || isOpponent(board[nr][nc], isWhite))) {
                        moves.push([nr, nc]);
                    }
                }
            }
            return moves;
        }

        function inBounds(r, c) {
            return r >= 0 && r < 8 && c >= 0 && c < 8;
        }

        function isOpponent(piece, isWhite) {
            return (isWhite && piece === piece.toLowerCase()) || (!isWhite && piece === piece.toUpperCase());
        }

        function resetGame() {
            board = [
                ['r','n','b','q','k','b','n','r'],
                ['p','p','p','p','p','p','p','p'],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['P','P','P','P','P','P','P','P'],
                ['R','N','B','Q','K','B','N','R']
            ];
            selected = null;
            possibleMoves = [];
            turn = 'w';
            renderBoard();
        }

        window.onload = () => {
            renderBoard();
        };
    </script>
    <title>Chess Game</title>
</head>
<body>
    <h1>Chess Game</h1>
    <div class="controls">
        <button onclick="resetGame()">Reset Game</button>
        <span id="turn-indicator">Turn: White</span>
    </div>
    <div id="board" class="chess-board"></div>
</body>
</html>